/**
 * Script to prepare data and start Firebase emulators
 * Usage: node src/scripts/setupEmulatorWithData.js
 */
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

console.log(
  `${colors.magenta}======= Setting up Firebase Emulators with Data =======${colors.reset}`,
);

// Paths to data files
const srcDataDir = path.join(process.cwd(), 'src', 'data');
const firebaseDataPath = path.join(srcDataDir, 'firebase-data.json');
const algoliaDataPath = path.join(srcDataDir, 'algolia-data.json');

// Temporary directory for emulator data
const emulatorDataDir = path.join(process.cwd(), 'tmp', 'emulator-data');

// Ensure tmp directory exists
if (!fs.existsSync(path.join(process.cwd(), 'tmp'))) {
  fs.mkdirSync(path.join(process.cwd(), 'tmp'), { recursive: true });
}

// Ensure emulator-data directory exists and is empty
if (fs.existsSync(emulatorDataDir)) {
  fs.rmSync(emulatorDataDir, { recursive: true, force: true });
}
fs.mkdirSync(emulatorDataDir, { recursive: true });

// Check if data files exist
if (!fs.existsSync(firebaseDataPath)) {
  console.error(
    `${colors.red}Error: Firebase data file not found at ${firebaseDataPath}${colors.reset}`,
  );
  process.exit(1);
}

if (!fs.existsSync(algoliaDataPath)) {
  console.error(
    `${colors.red}Error: Algolia data file not found at ${algoliaDataPath}${colors.reset}`,
  );
  process.exit(1);
}

console.log(`${colors.cyan}Found data files:${colors.reset}`);
console.log(`- Firebase: ${firebaseDataPath}`);
console.log(`- Algolia: ${algoliaDataPath}`);

/**
 * Create a simplified version of the data for Firestore emulator
 */
function prepareFirestoreData(sourceData) {
  console.log(`${colors.yellow}Converting Firebase data to Firestore format...${colors.reset}`);

  // Create a new data structure for firestore
  const firestoreData = {};

  // Process each collection
  for (const collection of Object.keys(sourceData)) {
    firestoreData[collection] = sourceData[collection];
  }

  return firestoreData;
}

try {
  // Read firebase data
  console.log(`${colors.cyan}Reading Firebase data...${colors.reset}`);
  const firebaseData = JSON.parse(fs.readFileSync(firebaseDataPath, 'utf-8'));

  // Set up Firestore export structure
  const firestoreDir = path.join(emulatorDataDir, 'firestore');
  fs.mkdirSync(firestoreDir, { recursive: true });

  // Process each collection and write to separate files for easier import
  const processedData = prepareFirestoreData(firebaseData);

  // Write each collection to its own file
  for (const collection of Object.keys(processedData)) {
    const collectionDir = path.join(firestoreDir, collection);
    fs.mkdirSync(collectionDir, { recursive: true });

    const documents = processedData[collection];
    for (const docId of Object.keys(documents)) {
      const documentPath = path.join(collectionDir, `${docId}.json`);
      fs.writeFileSync(documentPath, JSON.stringify(documents[docId]));
    }

    console.log(
      `${colors.green}Created collection: ${collection} with ${Object.keys(documents).length} documents${colors.reset}`,
    );
  }

  console.log(
    `${colors.green}Firebase data prepared successfully at ${emulatorDataDir}${colors.reset}`,
  );

  // Make sure the Algolia mock data is also set up
  console.log(`${colors.cyan}Setting up Algolia mock data...${colors.reset}`);
  const algoliaDir = path.join(process.cwd(), 'src', 'mocks');
  if (!fs.existsSync(algoliaDir)) {
    fs.mkdirSync(algoliaDir, { recursive: true });
  }

  // Create or update the Algolia mock implementation
  console.log(`${colors.cyan}Creating Algolia mock implementation...${colors.reset}`);
  const algoliaData = JSON.parse(fs.readFileSync(algoliaDataPath, 'utf-8'));

  const algoliaImplementation = `/**
 * Algolia mock implementation for local development
 * This file is auto-generated by the setupEmulatorWithData script
 */
import { SearchResponse } from 'algoliasearch';

// The data from the Algolia data file
const mockData = ${JSON.stringify(algoliaData, null, 2)};

// Mock search function that filters based on search query
export function mockAlgoliaSearch(query: string): Promise<SearchResponse<any>> {
  const hits = query
    ? mockData.filter(item => {
        const searchText = \`\${item.firstName} \${item.middleName || ''} \${item.lastName}\`.toLowerCase();
        return searchText.includes(query.toLowerCase());
      })
    : [...mockData];

  return Promise.resolve({
    hits,
    nbHits: hits.length,
    page: 0,
    nbPages: 1,
    hitsPerPage: hits.length,
    exhaustiveNbHits: true,
    query,
    params: '',
    processingTimeMS: 1,
    processingTimingsMS: {
      afterFetch: {
        total: 1
      },
      request: {
        roundTrip: 1
      }
    }
  });
}

// Mock init function
export function mockAlgoliaInit(): { search: typeof mockAlgoliaSearch } {
  return {
    search: mockAlgoliaSearch
  };
}
`;

  fs.writeFileSync(path.join(algoliaDir, 'algoliaMock.ts'), algoliaImplementation);
  console.log(`${colors.green}Algolia mock data set up successfully${colors.reset}`);

  // Creating helper script to populate data manually if the import doesn't work
  const populateScriptPath = path.join(process.cwd(), 'tmp', 'populate-firestore.js');
  const populateScript = `const fs = require('fs');
const path = require('path');
const { initializeApp } = require('firebase/app');
const { getFirestore, collection, doc, setDoc, connectFirestoreEmulator } = require('firebase/firestore');

// Initialize Firebase (with dummy config, we'll use emulator)
const app = initializeApp({
  projectId: 'demo-clonedbook'
});

// Initialize Cloud Firestore and connect to the emulator
const db = getFirestore(app);
connectFirestoreEmulator(db, 'localhost', 8081);

// Read the data
const firebaseData = ${JSON.stringify(firebaseData)};

async function populateFirestore() {
  console.log('Starting to populate Firestore...');
  
  for (const collectionName of Object.keys(firebaseData)) {
    console.log(\`Populating collection: \${collectionName}\`);
    const documents = firebaseData[collectionName];
    
    for (const docId of Object.keys(documents)) {
      try {
        const docRef = doc(db, collectionName, docId);
        await setDoc(docRef, documents[docId]);
        console.log(\`Added document: \${collectionName}/\${docId}\`);
      } catch (error) {
        console.error(\`Error adding \${collectionName}/\${docId}: \${error}\`);
      }
    }
  }
  
  console.log('Finished populating Firestore!');
}

populateFirestore().catch(console.error);
`;

  fs.writeFileSync(populateScriptPath, populateScript);
  console.log(
    `${colors.green}Created Firestore population script at: ${populateScriptPath}${colors.reset}`,
  );
  console.log(`${colors.yellow}You can run it with: node tmp/populate-firestore.js${colors.reset}`);

  // Start emulators with the prepared data
  console.log(
    `\n${colors.magenta}Starting Firebase emulators with imported data...${colors.reset}`,
  );
  console.log(
    `${colors.yellow}Note: Press Ctrl+C to stop the emulators when done${colors.reset}\n`,
  );

  try {
    execSync(
      `firebase emulators:start --project demo-clonedbook --import=${emulatorDataDir} --export-on-exit=${emulatorDataDir}`,
      {
        stdio: 'inherit',
      },
    );
  } catch (error) {
    console.error(`${colors.red}Error starting emulators:${colors.reset}`, error.message);
    process.exit(1);
  }
} catch (error) {
  console.error(`${colors.red}Error:${colors.reset}`, error.message);
  process.exit(1);
}
